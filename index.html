<!DOCTYPE html>
<html>
<meta charset="utf-8">

<style>
    .bar {
        fill: steelblue;
    }

    .bar:hover {
        fill: brown;
    }

    .highlight {
        fill: brown;
    }

    .axis {
        font: 15px sans-serif;
        font-weight: bold;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .x.axis path {
        display: none;
    }
</style>

<title>2018 NCCU Information Visualization HW2</title>
<H2>2018 NCCU Information Visualization HW2</H2>
<!--
    <svg width="1270" height="500"></svg>
-->
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>

<body>
    <div>
        <h3>全臺用電比例長條圖</h3>
        <button type="submit" id="m1" class="remove" style="width:80px;height:40px;">Jan</button>
        <button type="submit" id="m2" class="remove" style="width:80px;height:40px;">Feb</button>
        <button type="submit" id="m3" class="remove" style="width:80px;height:40px;">Mar</button>
        <button type="submit" id="m4" class="remove" style="width:80px;height:40px;">Apr</button>
        <button type="submit" id="m5" class="remove" style="width:80px;height:40px;">May</button>
        <button type="submit" id="m6" class="remove" style="width:80px;height:40px;">Jun</button>
        <button type="submit" id="m7" class="remove" style="width:80px;height:40px;">Jul</button>
        <button type="submit" id="m8" class="remove" style="width:80px;height:40px;">Aug</button>
        <button type="submit" id="m9" class="remove" style="width:80px;height:40px;">Sep</button>
        <button type="submit" id="m10" class="remove" style="width:80px;height:40px;">Oct</button>
        <button type="submit" id="m11" class="remove" style="width:80px;height:40px;">Nov</button>
        <button type="submit" id="m12" class="remove" style="width:80px;height:40px;">Dec</button>
        <br>
    </div>
    <script>
        $('.remove').click(removeSvg);
        $('#m1').click(barChart1);
        $('#m2').click(barChart2);
        $('#m3').click(barChart3);
        $('#m4').click(barChart4);
        $('#m5').click(barChart5);
        $('#m6').click(barChart6);
        $('#m7').click(barChart7);
        $('#m8').click(barChart8);
        $('#m9').click(barChart9);
        $('#m10').click(barChart12);
        $('#m11').click(barChart11);
        $('#m12').click(barChart12);

        function barChart1() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1280 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("jan.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; })
                // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars
                    .on("mouseover", onMouseOver) //Add listener for the mouseover event
                    .on("mouseout", onMouseOut)   //Add listener for the mouseout event
                    .transition().duration(300).attr("x", function (d) { return x(d.city); })
                    // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });
                // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart2() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("feb.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver) //Add listener for the mouseover event
                    .on("mouseout", onMouseOut)   //Add listener for the mouseout event
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart3() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("mar.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver) //Add listener for the mouseover event
                    .on("mouseout", onMouseOut)   //Add listener for the mouseout event
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart4() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("apr.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart5() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("may.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart6() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("jun.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart7() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("jul.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart8() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("aug.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart9() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("sep.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart10() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("oct.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart11() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("nov.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }

        function barChart12() {
            var margin = { top: 30, right: 20, bottom: 30, left: 40 },
                width = 1300 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // D3 scales = just math
            // x is a function that transforms from "domain" (data) into "range" (usual pixels)
            // domain gets set after the data loads
            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            // D3 Axis - renders a d3 scale in SVG
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left")
                .ticks(10, "%");

            // create an SVG element (appended to body)
            // set size
            // add a "g" element (think "group")
            // annoying d3 gotcha - the 'svg' variable here is a 'g' element
            // the final line sets the transform on <g>, not on <svg>
            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")

            svg.append("g")
                .attr("class", "y axis")
                .append("text") // just for the title (ticks are automatic)
                .attr("transform", "translate(35,-30)") // rotate the text!
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Frequency");

            // d3.tsv is a wrapper around XMLHTTPRequest, returns array of arrays (?) for a TSV file
            // type function transforms strings to numbers, dates, etc.
            d3.csv("dec.csv", type, function (error, data) {
                replay(data);
            });

            function type(d) {
                // + coerces to a Number from a String (or anything)
                d.frequency = +d.frequency;
                return d;
            }

            function replay(data) {
                var slices = [];
                for (var i = 0; i < data.length; i++) {
                    slices.push(data.slice(0, i + 1));
                }
                slices.forEach(function (slice, index) {
                    setTimeout(function () {
                        draw(slice);
                    }, index * 300);
                });
            }

            function draw(data) {
                console.table(data);
                // measure the domain (for x, unique letters) (for y [0,maxFrequency])
                // now the scales are finished and usable
                x.domain(data.map(function (d) { return d.city; }));
                y.domain([0, d3.max(data, function (d) { return d.frequency; })]);

                // another g element, this time to move the origin to the bottom of the svg element
                // someSelection.call(thing) is roughly equivalent to thing(someSelection[i])
                //   for everything in the selection\
                // the end result is g populated with text and lines!
                svg.select('.x.axis').transition().duration(300).call(xAxis);

                // same for yAxis but with more transform and a title
                svg.select(".y.axis").transition().duration(300).call(yAxis)

                // THIS IS THE ACTUAL WORK!
                var bars = svg.selectAll(".bar").data(data, function (d) { return d.city; }) // (data) is an array/iterable thing, second argument is an ID generator function

                bars.exit()
                    .transition()
                    .duration(300)
                    .attr("y", y(0))
                    .attr("height", height - y(0))
                    .style('fill-opacity', 1e-6)
                    .remove();

                // data that needs DOM = enter() (a set/selection, not an event!)
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", y(0))
                    .attr("height", height - y(0));

                // the "UPDATE" set:
                bars.on("mouseover", onMouseOver)
                    .on("mouseout", onMouseOut)
                    .transition().duration(300).attr("x", function (d) { return x(d.city); }) // (d) is one item from the data array, x is the scale object from above
                    .attr("width", x.rangeBand()) // constant, so no callback function(d) here
                    .attr("y", function (d) { /*console.log(d);*/ return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); }); // flip the height, because y's domain is bottom up, but SVG renders top down
            }
            //mouseover event handler function
            function onMouseOver(d, i) {
                d3.select(this).attr('class', 'highlight');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand() + 5)
                    .attr("y", function (d) { return y(d.frequency) - 10; })
                    .attr("height", function (d) { return height - y(d.frequency) + 10; });

                svg.append("text")
                    .attr('class', 'val')
                    .attr('x', function () {
                        return x(d.city);
                    })
                    .attr('y', function () {
                        return y(d.frequency) - 15;
                    })
                    .text(function () {
                        return [d.frequency * 100 + '%'];  // Value of the text
                    });
            }

            //mouseout event handler function
            function onMouseOut(d, i) {
                // use the text label class to remove label on mouseout
                d3.select(this).attr('class', 'bar');
                d3.select(this)
                    .transition()     // adds animation
                    .duration(400)
                    .attr('width', x.rangeBand())
                    .attr("y", function (d) { return y(d.frequency); })
                    .attr("height", function (d) { return height - y(d.frequency); });

                d3.selectAll('.val')
                    .remove()
            }
        }
        function removeSvg() {
            $('svg').remove();
        }
        barChart1();
    </script>

</body>

</html>